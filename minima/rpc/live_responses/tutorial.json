{
    "command": "tutorial",
    "status": true,
    "pending": false,
    "response": "\nADDRESS     ::= ADDRESS ( BLOCK )\nBLOCK       ::= STATEMENT_1 STATEMENT_2 ... STATEMENT_n\nSTATEMENT   ::= LET VARIABLE = EXPRESSION |\n                LET ( EXPRESSION_1 EXPRESSION_2 ... EXPRESSION_n ) = EXPRESSION |\n                IF EXPRESSION THEN BLOCK [ELSEIF EXPRESSION THEN BLOCK]* [ELSE\n                BLOCK] ENDIF |\n                WHILE EXPRESSION DO BLOCK ENDWHILE |\n                EXEC EXPRESSION |\n                MAST EXPRESSION |\n                ASSERT EXPRESSION |\n                RETURN EXPRESSION\nEXPRESSION  ::= RELATION\nRELATION    ::= LOGIC AND LOGIC  | LOGIC OR LOGIC  |\n                LOGIC XOR LOGIC  | LOGIC NAND LOGIC |\n                LOGIC NOR LOGIC  | LOGIC NXOR LOGIC | LOGIC\nLOGIC       ::= OPERATION EQ OPERATION  | OPERATION NEQ OPERATION  |\n                OPERATION GT OPERATION  | OPERATION GTE OPERATION  |\n                OPERATION LT OPERATION  | OPERATION LTE OPERATION  | OPERATION\nOPERATION   ::= ADDSUB & ADDSUB | ADDSUB | ADDSUB | ADDSUB ^ ADDSUB | ADDSUB\nADDSUB      ::= MULDIV + MULDIV | MULDIV - MULDIV | MULDIV % MULDIV |\n                MULDIV << MULDIV | MULDIV >> MULDIV | MULDIV\nMULDIV      ::= PRIME * PRIME | PRIME / PRIME | PRIME\nPRIME       ::= NOT PRIME |  NEG PRIME | ~PRIME | BASEUNIT\nBASEUNIT    ::= VARIABLE | VALUE | -NUMBER | GLOBAL | FUNCTION | ( EXPRESSION )\nVARIABLE    ::= [a-z]+\nVALUE       ::= NUMBER | HEX | STRING | BOOLEAN\nNUMBER      ::= ^[0-9]+(\\\\\\\\.[0-9]+)?\nHEX         ::= 0x[0-9a-fA-F]+\nSTRING      ::= [UTF8_String]\nBOOLEAN     ::= TRUE | FALSE\nFALSE       ::= 0\nTRUE        ::= NOT FALSE\nGLOBAL      ::= @BLOCK | @BLOCKTIME | @CREATED | @COINAGE | @INPUT |\n                @AMOUNT | @ADDRESS | @TOKENID | @COINID |\n                @SCRIPT | @TOTIN | @TOTOUT\nFUNCTION    ::= FUNC ( EXPRESSION_1 EXPRESSION_2 .. EXPRESSION_n )\nFUNC        ::= CONCAT | LEN | REV | SUBSET | GET | EXISTS | OVERWRITE |\n                REPLACE | SUBSTR | ADDRESS | SETLEN |\n                BOOL | HEX | NUMBER | STRING | UTF8 | ASCII |\n                ABS | CEIL | FLOOR | MIN | MAX | INC | DEC | SIGDIG | POW | SQRT |\n                BITSET | BITGET | BITCOUNT | PROOF | SHA2 | SHA3 |\n                SIGNEDBY | MULTISIG | CHECKSIG |\n                FUNCTION | SUMINPUT | SUMOUTPUT |\n                GETOUTADDR | GETOUTAMT | GETOUTTOK | GETOUTKEEPSTATE | VERIFYOUT |\n                GETINADDR | GETINAMT | GETINTOK | GETINID | VERIFYIN |\n                STATE | PREVSTATE | SAMESTATE\n\nGlobals\n\n@BLOCK       : Block number this transaction is in\n@CREATED     : Block number when this coin was created\n@COINAGE     : Difference between @BLOCK and @CREATED\n@INPUT       : Input number in the transaction\n@COINID      : CoinID of this input\n@AMOUNT      : Amount of this input\n@ADDRESS     : Address of this input\n@TOKENID     : TokenID of this input\n@SCRIPT      : Script for this input\n@TOTIN       : Total number of inputs for this transaction\n@TOTOUT      : Total number of outputs for this transaction\n\nFunctions\n\nCONCAT ( HEX_1 HEX_2 ... HEX_n )\nConcatenate the HEX values.\n\nLEN ( HEX|SCRIPT )\nLength of the data\n\nREV ( HEX )\nReverse the data\n\nSUBSET ( HEX NUMBER NUMBER )\nReturn the HEX subset of the data - start - length\n\nSETLEN ( NUMBER HEX )\nSet the length of a HEX value, trims if too large or pads with 0 if too short\n\nOVERWRITE ( HEX NUMBER HEX NUMBER NUMBER)\nCopy bytes from the first HEX and pos to the second HEX and pos, length the last NUMBER\n\nGET ( VALUE1 VALUE2 .. VALUEn )\nReturn the array value set with LET ( EXPRESSION EXPRESSION .. EXPRESSION )\n\nEXISTS ( VALUE1 VALUE2 .. VALUEn )\nChecks if the array value exists\n\nADDRESS ( STRING )\nReturn the address of the script\n\nREPLACE ( STRING STRING STRING )\nReplace in 1st string all occurrence of 2nd string with 3rd\n\nSUBSTR ( NUMBER NUMBER STRING )\nGet the substring                                                                                                                                                                             \n\nUTF8 ( HEX )\nConvert the HEX value to a UTF8 string\n\nASCII ( HEX )\nConvert the HEX value to an ASCII string\n\nBOOL ( VALUE )\nConvert to TRUE or FALSE value\n\nHEX ( SCRIPT )\nConvert SCRIPT to HEX\n\nNUMBER ( HEX )\nConvert HEX to NUMBER\n\nSTRING ( HEX )\nConvert a HEX value to SCRIPT\n\nABS ( NUMBER )\nReturn the absolute value of a number\n\nCEIL ( NUMBER )\nReturn the number rounded up\n\nFLOOR ( NUMBER )\nReturn the number rounded down\n\nMIN ( NUMBER NUMBER )\nReturn the minimum value of the 2 numbers\n\nMAX ( NUMBER NUMBER )\nReturn the maximum value of the 2 numbers\n\nINC ( NUMBER )\nIncrement a number\n\nDEC ( NUMBER )\nDecrement a number\n\nPOW ( NUMBER NUMBER )\nReturns the power of N of a number. N must be a whole number asb(n) < 1 million\n\nSQRT ( NUMBER )\nReturns the square root\n\nSIGDIG ( NUMBER NUMBER )\nSet the significant digits of the number\n\nBITSET ( HEX NUMBER BOOLEAN )\nSet the value of the BIT at that Position to 0 or 1\n\nBITGET ( HEX NUMBER )\nGet the BOOLEAN value of the bit at the position\n\nBITCOUNT ( HEX )\nCount the number of bits set in a HEX value\n\nPROOF ( HEX|STRING NUMBER HEX NUMBER HEX )\nCheck the mmr data, mmr root, with mmr proof are correct. Use 0 Numbers for non-sum mmr trees. Same as mmrproof on Minima\n\nSHA2 ( HEX|STRING )\nReturns the SHA2 value of the HEX value\n\nSHA3 ( HEX|STRING )\nReturns the SHA3 value of the HEX value\n\nSIGNEDBY ( HEX )\nReturns true if the transaction is signed by this public key\n\nMULTISIG ( NUMBER HEX1 HEX2 .. HEXn )\nReturns true if the transaction is signed by N of the public keys\n\nCHECKSIG ( HEX HEX HEX)\nCheck public key, data and signature\n\nGETOUTADDR ( NUMBER )\nReturn the HEX address of the specified output\n\nGETOUTAMT ( NUMBER )\nReturn the amount of the specified output\n\nGETOUTTOK ( NUMBER )\nReturn the token id of the specified output\n\nGETOUTKEEPSTATE ( NUMBER )\nIs the specified output keeping the state\n\nVERIFYOUT ( NUMBER HEX NUMBER HEX BOOL )\nVerify the output has the specified  address, amount, tokenid and keepstate\n\nGETINADDR ( NUMBER )\nReturn the HEX address of the specified input\n\nGETINAMT ( NUMBER )\nReturn the amount of the specified input\n\nGETINTOK ( NUMBER )\nReturn the token id of the specified input\n\nVERIFYIN ( NUMBER HEX NUMBER HEX )\nVerify the input has the specified address, amount and tokenid\n\nSUMINPUTS ( HEX )\nSum the input values of this token type\n\nSUMOUTPUTS ( HEX )\nSum the output values of this token type\n\nSTATE ( NUMBER )\nReturn the state value for the given number\n\nPREVSTATE ( NUMBER )\nReturn the state value stored in the coin MMR data - when the coin was created\n\nSAMESTATE ( NUMBER NUMBER )\nReturn TRUE if the previous state and current state are the same for the start and end positions\n\nFUNCTION ( STRING VALUE1 VALUE2.. VALUEn )\nGeneric Function. Run the script after replacing $1, $2.. $n with the provided parameters and use returnvalue as the returned result\n"
}
